
#include "base64.h"

/*****************************************************************
*                                                                *
*  encode()                                                      *
*                                                                *
*****************************************************************/
/*****************************************************************
*                                                                *
*  length()                                                      *
*                                                                *
*****************************************************************/
/*****************************************************************
*                                                                *
*  decode()                                                      *
*                                                                *
*****************************************************************/
//version of base64 decoder using comparisons
int base64::decode(char *bstr,void *data)
{
    unsigned char symbol[4];
    unsigned int i=0,p=0;
    unsigned char k=0;
    while(bstr[i] && bstr[i]!='=')
    {
        if(bstr[i]>='A' && bstr[i]<='Z')symbol[k]=bstr[i]-'A';
        else if(bstr[i]>='a' && bstr[i]<='z')symbol[k]=bstr[i]-'a'+26;
        else if(bstr[i]>='0' && bstr[i]<='9')symbol[k]=bstr[i]-'0'+26+26;
        else if(bstr[i]=='+')symbol[k]=62;
        else if(bstr[i]=='/')symbol[k]=63;
        else
        {
            return 1;
        }
        if(k==3)
        {
            ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
            ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
            ((unsigned char *)data)[p+2]=symbol[2]<<6 | symbol[3];
            p+=3;
        }
        i++;
        k++;
        k%=4;
    }
    if(k==1)
    {
        return 1;
    }
    else if(k==2)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
    }
    else if(k==3)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
        ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
    }
    return 0;
}
//version of base64url decoder using comparisons
int base64::decode_url(char *bstr,void *data)
{
    unsigned char symbol[4];
    unsigned int i=0,p=0;
    unsigned char k=0;
    while(bstr[i] && bstr[i]!='=')
    {
        if(bstr[i]>='A' && bstr[i]<='Z')symbol[k]=bstr[i]-'A';
        else if(bstr[i]>='a' && bstr[i]<='z')symbol[k]=bstr[i]-'a'+26;
        else if(bstr[i]>='0' && bstr[i]<='9')symbol[k]=bstr[i]-'0'+26+26;
        else if(bstr[i]=='-')symbol[k]=62;
        else if(bstr[i]=='_')symbol[k]=63;
        else
        {
            return 1;
        }
        if(k==3)
        {
            ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
            ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
            ((unsigned char *)data)[p+2]=symbol[2]<<6 | symbol[3];
            p+=3;
        }
        i++;
        k++;
        k%=4;
    }
    if(k==1)
    {
        return 1;
    }
    else if(k==2)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
    }
    else if(k==3)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
        ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
    }
    return 0;
}
//decoder for individual alphabet -- VERSION A (inner loop)
int base64::decode(char *bstr,void *data,const char *sym,char pad)
{
    unsigned char symbol[4];
    unsigned int i=0,p=0;
    unsigned int j;
    unsigned char k=0;
    while(bstr[i] && bstr[i]!=pad)
    {
        j=0;
        while(j<64)
        {
            if(bstr[i]==sym[j])
            {
                symbol[k]=j;
                break;
            }
            j++;
        }
        if(j==64)return 1;
        if(k==3)
        {
            ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
            ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
            ((unsigned char *)data)[p+2]=symbol[2]<<6 | symbol[3];
            p+=3;
        }
        i++;
        k++;
        k%=4;
    }
    if(k==1)
    {
        return 1;
    }
    else if(k==2)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
    }
    else if(k==3)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
        ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
    }
    return 0;
}
//decoder for individual alphabet -- VERSION B
int base64::decode(char *bstr,void *data,const char *sym,char pad)
{
    unsigned char symbol[4];
    unsigned int i=0,p=0;
    unsigned int j;
    unsigned char k=0;
    char symf[256];
    memset(symf,-1,256*sizeof(char));
    for(j=0;j<64;j++)symf[(unsigned char)sym[j]]=j;
    while(bstr[i] && bstr[i]!=pad)
    {
        symbol[k]=symf[(unsigned char)bstr[i]];
        if(!symbol[k])return 1;
        if(k==3)
        {
            ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
            ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
            ((unsigned char *)data)[p+2]=symbol[2]<<6 | symbol[3];
            p+=3;
        }
        i++;
        k++;
        k%=4;
    }
    if(k==1)
    {
        return 1;
    }
    else if(k==2)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
    }
    else if(k==3)
    {
        ((unsigned char *)data)[p]=symbol[0]<<2 | symbol[1]>>4;
        ((unsigned char *)data)[p+1]=symbol[1]<<4 | symbol[2]>>2;
    }
    return 0;
}
